# AUTOGENERATED! DO NOT EDIT! File to edit: 00_coloured_spectra.ipynb (unless otherwise specified).

__all__ = ['PLANCK_CONSTANT', 'SPEED_OF_LIGHT', 'BOLTZMAN_CONSTANT', 'Blackbody', 'piecewise_Guass', 'wavelength2xyz',
           'plot_cie_xyz_matching_functions', 'xyz2sRGB', 'plot_colour', 'sRGB2hex', 'plot_wavelength_colours',
           'wavelength_intensity2hsv', 'hsv_map', 'pure_hue_palette', 'plot_hsv_LUT_spectrum',
           'colour_hyperspectral_line', 'spectra2sRGB', 'hyperspec_line2colour']

# Cell

# libraries
import numpy as np
import matplotlib.pyplot as plt
import cv2
import pandas as pd
import pickle
from PIL import Image
from tqdm import tqdm

# physical constants
PLANCK_CONSTANT   = 6.62607015e-34 # J.s
SPEED_OF_LIGHT    = 299_792_458    # m/s
BOLTZMAN_CONSTANT = 1.38064852e-23 # J/K

# Cell

class Blackbody():
    """Computes blackbody spectra for a given temperature."""
    def __init__(self,T_K,λ_nm=None):
        """T_K is temperature in Kelvin. λ_nm is wavelength in nanometers."""
        self.T_K  = T_K
        self.λ_nm = λ_nm
        self.B_λT = None

        if T_K == 0:
            raise InputError("Temperature cannot be absolute zero.")

        if λ_nm is not None:
            self.__call__(update=True)

    def __repr__(self):
        return f"Blackbody temperature = {self.T_K} K\nProvided nm wavelength input = #({np.size(self.λ_nm)}) {self.λ_nm}"

    def __call__(self,λ_nm=None,update=False):
        """λ_nm is wavelength in nanometers."""
        if λ_nm is None:
            if self.λ_nm is None:
                raise InputError("Please provide a wavelength (in nanometers).")
            else:
                λ_nm = self.λ_nm

        is_array = len(np.shape(λ_nm)) # 0 if given a scalar, 1 if given a 1D array/list
        if is_array > 1:
            raise InputError("Please provide a scalar or 1D array.")
        elif is_array == 0: # empty tuple (measure zero scalar)
            B_λT = self.spec_intensity(λ_nm)
        else:
            B_λT = np.zeros(np.shape(λ_nm))
            for i in range(np.shape(λ_nm)[0]):
                B_λT[i] = self.spec_intensity(λ_nm[i])

        if update:
            self.λ_nm = λ_nm
            self.B_λT = B_λT
        return B_λT

    def __getitem__(self,key):
        return (self.λ_nm[key],self.B_λT[key])

    def spec_intensity(self,λ_nm:"scalar or 1D array"):
        """Spectral Intensity from Planck's law"""
        return (2*PLANCK_CONSTANT*SPEED_OF_LIGHT**2)/(λ_nm*1e-9)**5 / (
                np.exp((PLANCK_CONSTANT*SPEED_OF_LIGHT)/(λ_nm*1e-9*BOLTZMAN_CONSTANT*self.T_K)) - 1)

    def plot(self):
        """show blackbody spectra"""
        if self.λ_nm is None:
            self.λ_nm = np.arange(400,701,5)
            self.__call__(update=True)
        plt.plot(self.λ_nm,self.B_λT)
        plt.xlabel("wavelength (nm)")
        plt.ylabel("intensity ($W·sr^{−1}·m^{−3}$)")
        plt.grid('on')




# Cell
def piecewise_Guass(x,α,μ,σ1,σ2):
    t = (x-μ) / ( σ1 if x < μ else σ2 )
    return α * np.exp(-(t**2)/2)


# Cell
def wavelength2xyz(λ):
    """λ is in nanometers"""
    λ *= 10 # convert to angstroms for the below formulas
    x̅ = piecewise_Guass(λ,  1.056, 5998, 379, 310) + \
        piecewise_Guass(λ,  0.362, 4420, 160, 267) + \
        piecewise_Guass(λ, -0.065, 5011, 204, 262)
    y̅ = piecewise_Guass(λ,  0.821, 5688, 469, 405) + \
        piecewise_Guass(λ,  0.286, 5309, 163, 311)
    z̅ = piecewise_Guass(λ,  1.217, 4370, 118, 360) + \
        piecewise_Guass(λ,  0.681, 4590, 260, 138)
    return np.array([x̅,y̅,z̅])



# Cell
def plot_cie_xyz_matching_functions():
    λs = np.arange(400,701,5) # nm
    xs = np.zeros(np.shape(λs)); ys = xs.copy(); zs = xs.copy()

    for i in range(len(λs)):
        x,y,z = wavelength2xyz(λs[i])
        xs[i] = x; ys[i] = y; zs[i] = z

    plt.plot(λs,xs,'r',label="X(λ)")
    plt.plot(λs,ys,'g',label="Y(λ)")
    plt.plot(λs,zs,'b',label="Z(λ)")
    plt.grid()
    plt.legend()
    plt.xlabel("λ (nm)")
    plt.ylabel("CIE XYZ value")

# Cell
def xyz2sRGB(xyz,mode="WHITEN"):
    """converts xyz to sRGB. mode can be 'WHITEN' or 'CLAMP' """
    # from http://www.color.org/sRGB.xalter
    xyz2sRGB_matrix = np.array ([[ 3.2410, -1.5374, -0.4986],
                                [-0.9692,  1.8760,  0.0416],
                                [ 0.0556, -0.2040,  1.0570]])
    sRGB = np.dot(xyz2sRGB_matrix, xyz)

    if mode == "CLAMP":
        sRGB = np.clip(sRGB,0,np.max(sRGB))
    elif mode == "WHITEN" and np.min(sRGB) < 0:
        min_sRGB = np.min(sRGB)
        max_sRGB = np.max(sRGB)
        sRGB -= min_sRGB
        sRGB *= max_sRGB/(max_sRGB-min_sRGB)

    return np.uint8(np.clip(np.round(sRGB*256),0,255))



# Cell
def plot_colour(sRGB):
    plt.imshow(np.reshape(sRGB,(1,1,3)))
    plt.axis('off')


# Cell
def sRGB2hex(sRGB):
    """converts sRGB to hex colour"""
    return '#%02X%02X%02X' % (sRGB[0],sRGB[1],sRGB[2])



# Cell
def plot_wavelength_colours(mode="WHITEN"):
    """mode can be 'WHITEN' or 'CLAMP' """
    λs = np.arange(400,701,1) # nm

    bar = np.zeros((1,len(λs),3),dtype=np.uint8)

    for i in range(len(λs)):
        bar[0,i,:] = xyz2sRGB(wavelength2xyz(λs[i]),mode)

    fig = plt.imshow(bar, interpolation='none', extent=[np.min(λs),np.max(λs),0,20])
    plt.xlabel("λ (nm)")
    fig.axes.get_yaxis().set_visible(False)

# Cell

def wavelength_intensity2hsv():
    """I want to map the invisible UV and NIR to the colour white with saturation depending on intensity.
    This is unphysical but makes for a nice visualisation of wavelength intensity profile!"""

    λs = np.arange(300,750,5) # nm
    bar = np.zeros((1,len(λs),3),dtype=np.uint8)

    for i in range(len(λs)):
        bar[0,i,:] = xyz2sRGB(wavelength2xyz(λs[i]),mode='WHITEN')

    bar_hsv = cv2.cvtColor(bar, cv2.COLOR_RGB2HSV_FULL)

    plt.plot(λs,bar_hsv[0,:,0],label="hue")
    plt.plot(λs,bar_hsv[0,:,1],label="sat")
    plt.plot(λs,bar_hsv[0,:,2],label="val")
    plt.legend()
    plt.grid('on')

    #df = pd.DataFrame({"wavelength (nm)":λs,"hue":bar_hsv[0,:,0],"val":bar_hsv[0,:,2]})





# Cell
def hsv_map(λ:"wavelength nm",I:"intensity 0-1"=1.)->"HSV":
    if λ <= 425:
        return np.uint8([190,np.clip(255-5*(425-λ),0,255),255*I])
    elif λ <= 610:
        return np.uint8([190*(1-(λ-425)/(610-425)),255,255*I])
    elif λ > 610:
        return np.uint8([0,np.clip(2.55*(710-λ),0,255),255*I])



# Cell
import colorsys
def pure_hue_palette(λ:"wavelength nm",n:"palette size >= 3"=16):
    sRGBs = np.zeros((3,n),dtype=np.uint8)
    intensities = np.linspace(0.,1.,num=n)
    for i in range(n):
        hsv = np.float64(hsv_map(λ,intensities[i]))/255.
        sRGBs[:,i] = np.uint8( 255*np.float64(colorsys.hsv_to_rgb(*hsv)) )

    return [sRGB2hex(sRGBs[:,i]) for i in range(n)]

# Cell
def plot_hsv_LUT_spectrum():
    λs = np.arange(350,751,1) # nm
    hsv_bar = np.zeros((1,len(λs),3),dtype=np.uint8)

    for i in range(len(λs)):
        hsv_bar[0,i,:] = hsv_map(λs[i],1.)

    bar = cv2.cvtColor(hsv_bar, cv2.COLOR_HSV2RGB_FULL)

    fig = plt.imshow(bar, interpolation='none', extent=[np.min(λs),np.max(λs),0,20])
    plt.xlabel("λ (nm)")
    fig.axes.get_yaxis().set_visible(False)



# Cell

#export
def colour_hyperspectral_line(λs,img):
    """λs is the index for x axis, y axis is the cross track dimension"""

    coloured_img = np.zeros((*np.shape(img),3),dtype=np.uint8)

    for i in tqdm(range(np.shape(img)[0])):
        for j in range(len(λs)):
            coloured_img[i,j,:] = hsv_map(λs[j],img[i,j])

    coloured_img = cv2.cvtColor(coloured_img, cv2.COLOR_HSV2RGB_FULL)

    plt.imshow(coloured_img,extent=[np.min(λs),np.max(λs),0,np.shape(img)[0]])
    plt.xlabel("wavelengths (nm)")
    plt.ylabel("cross-track")


# Cell
def spectra2sRGB(λs,Is:"1D spectrum array"):
    xyz = np.zeros((3,),dtype=np.float64)
    for λ,I in zip(λs,Is):
        xyz += wavelength2xyz(λ)*I

    x = xyz[0]/np.sum(xyz)
    y = xyz[1]/np.sum(xyz)
    z = 1-x-y

    return xyz2sRGB(np.array([x,y,z]))



# Cell
def hyperspec_line2colour(λs,img):
    """This grabs a line of hyperspectral data and returns a column of the observed colour cross-track"""
    coloured_line = np.zeros((np.shape(img)[0],1,3),dtype=np.uint8)

    for i in tqdm(range(np.shape(img)[0])):
        coloured_line[i,0,:] = spectra2sRGB(λs,img[i,:])

    fig = plt.imshow(coloured_line, interpolation='none', extent=[0,20,0,np.shape(img)[0]])
    plt.ylabel("cross-track")
    fig.axes.get_xaxis().set_visible(False)

