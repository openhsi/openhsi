# AUTOGENERATED! DO NOT EDIT! File to edit: 00_data.ipynb (unless otherwise specified).

__all__ = ['Array', 'Shape', 'CircArrayBuffer', 'CameraProperties', 'DataCube']

# Cell

from fastcore.foundation import patch
from fastcore.meta import delegates
import xarray as xr
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.interpolate import interp1d
from PIL import Image
from scipy.signal import decimate

from typing import Iterable, Union, Callable, List, TypeVar, Generic, Tuple, Optional
import datetime
import json
import pickle

# numpy.ndarray type hints
Shape = TypeVar("Shape"); DType = TypeVar("DType")
class Array(np.ndarray, Generic[Shape, DType]):
    """
    Use this to type-annotate numpy arrays, e.g.
        image: Array['H,W,3', np.uint8]
        xy_points: Array['N,2', float]
        nd_mask: Array['...', bool]
    from: https://stackoverflow.com/questions/35673895/type-hinting-annotation-pep-484-for-numpy-ndarray
    """
    pass

# Cell

class CircArrayBuffer():
    """Circular Buffer implementation on ndarrays. Each push is a (n-1)darray.
    The insert axis can be specified and modified after initialisation using `update_axis`."""

    def __init__(self, size:tuple = (100,100), axis:int = 0, dtype:type = np.int32, show_func:Callable[[np.ndarray],None] = None):
        """Initialise array and write pointer"""
        self.data = np.zeros(size, dtype=dtype)
        self.size = size
        self.axis = axis
        self.write_pos = [slice(None,None,None) if i != axis else 0 for i in range(len(size)) ]
        self.show_func = show_func

    def __getitem__(self, key:slice):
        return self.data[key]

    def update_axis(self, axis:int, write_pos:int = 0):
        """Changes the write axis in array"""
        self.axis = axis
        self.write_pos = [slice(None,None,None) if i != axis else write_pos for i in range(len(self.size)) ]

    def push(self, line:np.ndarray):
        """Writes a (n-1)darray into the ndarray"""
        self.data[tuple(self.write_pos)] = line
        self.write_pos[self.axis] += 1

        # Loop back if buffer is full
        if self.write_pos[self.axis] == self.size[self.axis]:
            self.write_pos[self.axis] = 0

    def show(self):
        """Display the data """
        if self.show_func is None:
            if len(self.size) == 2:
                plt.imshow(self.data,cmap="gray")
                plt.xlabel("wavelength index")
                plt.ylabel("cross-track")
                plt.show()
            elif len(self.size) == 3:
                # Sum over the last dimensions (assumed wavelength) and show as monochrome
                plt.imshow(np.sum(self.data,axis=-1),cmap="gray")
                plt.xlabel("along-track")
                plt.ylabel("cross-track")
                plt.show()
            elif len(self.size) == 1:
                print(f"#({self.size[0]}) {self.data}")
        elif self.show_func is not None:
            self.show_func(self.data)
        else:
            print("Unsupported array shape. Please use 2D or 3D shapes or use your own custom show function")


# Cell

class CameraProperties():
    """Save and load OpenHSI camera settings and calibration"""
    def __init__(self, txt_path:str = "assets/cam_settings.txt", pkl_path:str = "assets/cam_calibration.pkl"):
        """Load the settings and calibration files"""
        self.txt_path = txt_path
        self.pkl_path = pkl_path

        with open(self.txt_path) as json_file:
            self.settings = json.load(json_file)
        with open(self.pkl_path,'rb') as handle:
            self.calibration = pickle.load(handle)

        self.wavelengths = np.arange(*self.settings["index2wavelength_range"])

    def __repr__(self):
        return "settings = \n" + self.settings.__repr__() + \
               "\n\ncalibration = \n" + self.calibration.__repr__()

    def dump(self):
        """Save the settings and calibration files"""
        with open(self.txt_path, 'w') as outfile:
            json.dump(self.settings, outfile,indent=4,)
        with open(self.pkl_path,'wb') as handle:
            pickle.dump(self.calibration,handle)


# Cell

@patch
def tfm_setup(self:CameraProperties, more_setup:Callable[[CameraProperties],None] = None, dtype:Union[np.int32,np.float32] = np.int32):
    """Setup for transforms"""
    # for fast smile correction
    self.smiled_size = (np.ptp(self.settings["row_slice"]), self.settings["resolution"][1] - np.max(self.calibration["smile_shifts"]) )
    self.line_buff = CircArrayBuffer(self.smiled_size, axis=0, dtype=dtype)

    # for collapsing spectral pixels into bands
    self.byte_sz = dtype(0).nbytes
    self.width = np.uint16(self.settings["fwhm_nm"]*self.settings["resolution"][1]/np.ptp(self.settings["index2wavelength_range"][:2]))
    self.bin_rows = np.ptp(self.settings["row_slice"])
    self.bin_cols = self.settings["resolution"][1] - np.max(self.calibration["smile_shifts"])
    self.reduced_shape = (self.bin_rows,self.bin_cols//self.width,self.width)

    # update the wavelengths
    self.binned_wavelengths = np.linspace(*self.settings["index2wavelength_range"][:2],num=self.settings["resolution"][1],dtype=np.float32)[np.max(self.calibration["smile_shifts"]):]
    self.binned_wavelengths = np.lib.stride_tricks.as_strided(self.binned_wavelengths,
                                        strides=(self.width*4,4), # assumed np.float32
                                        shape=(len(self.binned_wavelengths)//self.width,self.width))
    self.binned_wavelengths = np.around(self.binned_wavelengths.mean(axis=1),decimals=1)

    # precompute some reference data for converting digital number to radiance
    self.nearest_exposure = self.calibration["rad_ref"].sel(exposure=self.settings["exposure_ms"],method="nearest").exposure
    #
    self.dark_current = np.array( self.settings["exposure_ms"]/self.nearest_exposure * \
                        self.calibration["rad_ref"].sel(exposure=self.nearest_exposure,luminance=0).isel(luminance=0) )
    self.ref_luminance = np.array( self.settings["exposure_ms"]/self.nearest_exposure * \
                         self.calibration["rad_ref"].sel(exposure=self.nearest_exposure,luminance=self.settings["luminance"]) - \
                         self.dark_current )
    self.spec_rad_ref = np.float64(self.calibration["sfit"](self.wavelengths))



    if more_setup is not None:
        more_setup(self)


# Cell

@patch
def crop(self:CameraProperties, x:np.ndarray) -> np.ndarray:
    """Crops to illuminated area"""
    return x[self.settings["row_slice"][0]:self.settings["row_slice"][1],:]

@patch
def fast_smile(self:CameraProperties, x:np.ndarray) -> np.ndarray:
    """Apply the fast smile correction procedure"""
    for i in range(self.smiled_size[0]):
            self.line_buff.push(x[i,self.calibration["smile_shifts"][i]:self.calibration["smile_shifts"][i]+self.smiled_size[1]])
    return self.line_buff.data

@patch
def fast_bin(self:CameraProperties, x:np.ndarray) -> np.ndarray:
    """Changes the view of the datacube so that everything that needs to be binned is in the last axis. The last axis is then binned."""
    buff = np.lib.stride_tricks.as_strided(x, shape=self.reduced_shape,
                        strides=(self.bin_cols*self.byte_sz,self.width*self.byte_sz,self.byte_sz))
    return buff.sum(axis=-1)



# Cell

@patch
def pipeline(self:CameraProperties, x:np.ndarray, tfms:List[Callable[[np.ndarray],np.ndarray]] = lambda o: o) -> np.ndarray:
    """Compose a list of transforms"""
    for f in tfms:
        x = f(x)
    return x


# Cell

@delegates()
class DataCube(CameraProperties):
    """docstring."""

    def __init__(self, n_lines:int = 16, dtype:type = np.int32, **kwargs):

        super().__init__(**kwargs)

        self.timestamps = pd.date_range(datetime.datetime.now(), periods=n_lines, freq="1s").to_numpy() # preallocate array
        self.dc = CircArrayBuffer(size=self.sz, axis=1, dtype=dtype)

        self.tfm_list = [self.fast_smile]


    def __repr__(self):
        return f"DataCube:\n" + self.dc.__repr__()

    def push(self, x:np.ndarray):
        """Applies the composed tranforms and writes the 2D array into the data cube. Stores a timestamp for each push."""

        self.timestamps[ self.write_pos[self.axis] ] = np.datetime64(datetime.datetime.now())

        self.dc.push( self.pipeline(x,self.tfm_list) )

    """
        for i in range(self.size[0]):
            self.line_buff.push(line[self.row_slice.start+i,self.shifts[i]:self.shifts[i]+self.line_buff.size[1]])

        buff = np.lib.stride_tricks.as_strided(self.line_buff.data,
                        shape=(self.rows,self.cols//self.width,self.width),
                        strides=(self.cols*self.byte_sz,self.width*self.byte_sz,self.byte_sz))
        super().push(buff.sum(axis=-1))

    def show(self,key):
        if isinstance(key[1],int):
            plt.imshow(self.data[key],extent=[*self.wavelength_range[:2],self.rows,0],cmap="gray")
        else:
            plt.imshow(self.data[key],cmap="gray")
        plt.colorbar()
        plt.show()
    """