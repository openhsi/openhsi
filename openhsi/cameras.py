# AUTOGENERATED! DO NOT EDIT! File to edit: 02_cameras.ipynb (unless otherwise specified).

__all__ = ['WebCamera', 'XimeaCamera', 'LucidCamera']

# Cell

from fastcore.foundation import patch
from fastcore.meta import delegates
import cv2
import numpy as np
import matplotlib.pyplot as plt
import warnings

# Cell

from .data import *
from .capture import *

# Cell

@delegates()
class WebCamera(OpenHSI):
    """Interface for webcam to test OpenHSI functionality"""
    def __init__(self, mode:str = None, **kwargs):
        """Initialise Webcam"""
        super().__init__(**kwargs)
        self.mode = mode
        if self.mode == "HgAr":
            self.gen = self.gen_sim_spectra()

        # Check if the webcam is opened correctly
        self.vid = cv2.VideoCapture(0)
        if not self.vid.isOpened():
            raise IOError("Cannot open webcam")

    def start_cam(self):
        pass

    def stop_cam(self):
        self.vid.release()
        cv2.destroyAllWindows()

    def get_img(self) -> np.ndarray:
        if self.mode == "HgAr":
            return next(self.gen)
        else:
            ret, frame = self.vid.read()
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
            frame = cv2.resize(frame, tuple(np.flip(self.settings["resolution"])), interpolation = cv2.INTER_AREA)
            if self.mode == "crop":
                frame[:self.settings["row_slice"][0],...] = 0
                frame[self.settings["row_slice"][1]:,...] = 0
            return frame

    def gen_sim_spectra(self):
        lines_nm = [254,436,546,764,405,365,578,750,738,697,812,772,912,801,842,795,706,826,852,727] # approx sorted by emission strength
        img = np.zeros(tuple(self.settings["resolution"]),dtype=np.uint8)
        wavelengths = np.linspace(self.settings["index2wavelength_range"][0],self.settings["index2wavelength_range"][1],num=self.settings["resolution"][1])

        strength = 255
        for line in lines_nm:
            indx = np.sum(wavelengths<line)
            if indx > 0 and indx < self.settings["resolution"][1]:
                img[:,indx-2:indx+2] = strength
                strength -= 5
        while True:
            yield img


# Cell

@delegates()
class XimeaCamera(OpenHSI):

    """Core functionality for Ximea cameras"""
    # https://www.ximea.com/support/wiki/apis/Python
    def __init__(self, xbinwidth:int = 896, xbinoffset:int = 528, exposure_ms:float = 10, serial_num:str = None, **kwargs):
        """Initialise Camera"""

        super().__init__(**kwargs)

        try:
            from ximea import xiapi
            self.xiapi=xiapi # make avalaible for later access just in case.
        except ModuleNotFoundError:
            warnings.warn("ModuleNotFoundError: No module named 'ximea'.",stacklevel=2)

        self.xicam = xiapi.Camera()

        self.xicam.open_device_by_SN(serial_num) if serial_num else self.xicam.open_device()

        print(f'Connected to device {self.xicam.get_device_sn()}')

        self.xbinwidth  = xbinwidth
        self.xbinoffset = xbinoffset
        self.exposure   = exposure_ms
        self.gain       = 0

        self.xicam.set_width(self.xbinwidth)
        self.xicam.set_offsetX(self.xbinoffset)
        self.xicam.set_exposure_direct(1000*self.exposure)
        self.xicam.set_gain_direct(self.gain)

        self.xicam.set_imgdataformat("XI_RAW16")
        self.xicam.set_output_bit_depth("XI_BPP_12")
        self.xicam.enable_output_bit_packing()
        self.xicam.disable_aeag()

        self.xicam.set_binning_vertical(2)
        self.xicam.set_binning_vertical_mode("XI_BIN_MODE_SUM")

        self.rows, self.cols = self.xicam.get_height(), self.xicam.get_width()
        self.img = xiapi.Image()

        #self.load_cam_settings()

    def __exit__(self, *args, **kwargs):
        self.xicam.stop_acquisition()
        self.xicam.close_device()

    def start_cam(self):
        self.xicam.start_acquisition()

    def stop_cam(self):
        self.xicam.stop_acquisition()

    def get_img(self) -> np.ndarray:
        self.xicam.get_image(self.img)
        return self.img.get_image_data_numpy()

# Cell


@delegates()
class LucidCamera(OpenHSI):

    """Core functionality for Lucid Vision Lab cameras"""

    # https://thinklucid.com/downloads-hub/
    def __init__(
        self,
        xbinwidth: int = 0,
        xbinoffset: int = 0,
        ybinwidth: int = 0,
        ybinoffset: int = 0,
        exposure_ms: float = 10,
        mac_addr: str = "1c:0f:af:01:7b:a0",
        **kwargs
    ):
        """Initialise Camera"""

        super().__init__(**kwargs)

        try:
            from arena_api.system import system as arsys

            self.arsys = arsys  # make avalaible for later access just in case.
            import ctypes
        except ModuleNotFoundError:
            warnings.warn(
                "ModuleNotFoundError: No module named 'arena_api'.", stacklevel=2
            )

        try:
            self.arsys.device_infos
            self.device = arsys.create_device(device_infos=[{"mac": mac_addr}])[0]
        except:
            warnings.warn(
                "DeviceNotFoundError: Please connect a lucid vision camera and run again.",
                stacklevel=2,
            )

        tl_stream_nodemap = self.device.tl_stream_nodemap
        tl_stream_nodemap["StreamAutoNegotiatePacketSize"].value = True
        tl_stream_nodemap["StreamPacketResendEnable"].value = True

        self.deviceSettings = self.device.nodemap.get_node(
            [
                "AcquisitionFrameRate",
                "AcquisitionFrameRateEnable",
                "AcquisitionMode",
                "AcquisitionStart",
                "AcquisitionStop",
                "BinningHorizontal",
                "BinningVertical",
                "DevicePower",
                "DeviceTemperature",
                "DeviceUpTime",
                "DeviceUserID",
                "ExposureAuto",
                "ExposureTime",
                "Gain",
                "GammaEnable",
                "Height",
                "OffsetX",
                "OffsetY",
                "PixelFormat",
                "ReverseX",
                "ReverseY",
                "Width",
            ]
        )

        #         print(f'Connected to device {self.deviceSettings['DeviceUserID'].value})

        self.xbinwidth = xbinwidth
        self.xbinoffset = xbinoffset
        self.ybinwidth = ybinwidth
        self.ybinoffset = ybinoffset
        self.exposure = exposure_ms
        self.gain = 0

        self.deviceSettings["Height"].value = (
            self.ybinwidth if self.ybinwidth else self.deviceSettings["Height"].max
        )
        self.deviceSettings["OffsetX"].value = (
            self.ybinoffset if self.ybinoffset else self.deviceSettings["OffsetY"].max
        )

        self.deviceSettings["Width"].value = (
            self.xbinwidth if self.xbinwidth else self.deviceSettings["Width"].max
        )
        self.deviceSettings["OffsetY"].value = (
            self.xbinoffset if self.xbinoffset else self.deviceSettings["OffsetX"].max
        )

        self.deviceSettings["ExposureAuto"].value = "Off"
        self.deviceSettings["ExposureTime"].value = (
            exposure_ms * 1000.0
        )  # requires time in us
        self.exposure = self.deviceSettings[
            "ExposureTime"
        ]  # exposure time rounds, so storing actual value

        self.deviceSettings["Gain"].value = 0.0

        self.deviceSettings["PixelFormat"].value = "Mono10Packed"

        self.deviceSettings["PixelFormat"]

        self.deviceSettings["BinningHorizontal"].value = 1

        self.rows, self.cols = (
            self.deviceSettings["Height"].value,
            self.deviceSettings["Width"].value,
        )

    def __exit__(self, *args, **kwargs):
        self.device.stop_stream()
        self.arsys.destroy_device()

    def start_cam(self):
        self.device.start_stream(1)

    def stop_cam(self):
        self.device.stop_stream()

    def get_img(self) -> np.ndarray:
        image_buffer = device.get_buffer()
        pdata_as16 = ctypes.cast(image_buffer.pdata, ctypes.POINTER(ctypes.c_ushort))
        nparray_reshaped = np.ctypeslib.as_array(
            pdata_as16, (image_buffer.height, image_buffer.width)
        )
        self.device.requeue_buffer(image_buffer)
        return nparray_reshaped

