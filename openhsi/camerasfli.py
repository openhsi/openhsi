# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/cameras-fli.ipynb.

# %% auto 0
__all__ = ['CWRAPPER', 'FirstLightCameraBase', 'FirstLightCamera']

# %% ../nbs/api/cameras-fli.ipynb 5
# monkey patching class methods using @patch
from fastcore.foundation import *
from fastcore.foundation import patch

# bring forth **kwargs from an inherited class for documentation
from fastcore.meta import delegates

# dependacies
import numpy as np
import ctypes
import matplotlib.pyplot as plt
import warnings
from tqdm import tqdm
from functools import partial
import time

from .capture import OpenHSI

# %% ../nbs/api/cameras-fli.ipynb 7
from flisdk import FliSdk_V2
CWRAPPER = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_void_p)

# %% ../nbs/api/cameras-fli.ipynb 8
@delegates()
class FirstLightCameraBase():
    """Interface for FirstLight camera"""
    def __init__(self, cam_idx:int = 0, **kwargs):
        """Initialise FirstLight camera"""
        super().__init__(**kwargs)
        
        self.latest_im = None
        self.nims_lefttolog = 0
        self.update_latestim = False
        
        # get context
        self.context = FliSdk_V2.Init()
        self.grabber_list = FliSdk_V2.DetectGrabbers(self.context)
        
        if len(self.grabber_list) == 0:
            raise RuntimeError("No grabber detected!")
        else:
            print(f"Grabbers detected: {self.grabber_list}")
        
        # initialise camera
        self.camera_list = FliSdk_V2.DetectCameras(self.context)
        
        if len(self.camera_list) == 0:
            raise RuntimeError("No camera detected!")
        else:
            print(f"Cameras detected: {self.camera_list}")
            
        print(f"Setting up camera {self.camera_list[cam_idx]}")
        if not FliSdk_V2.SetCamera(self.context, self.camera_list[cam_idx]):
            raise RuntimeError("Error while setting up camera.")
        
        print("Setting mode full.")
        FliSdk_V2.SetMode(self.context, FliSdk_V2.Mode.Full)

        if not FliSdk_V2.Update(self.context):
            raise RuntimeError("Error while updating SDK.")
        
        self.camdims = FliSdk_V2.GetCurrentImageDimension(self.context)
        
        # if FliSdk_V2.IsSerialCamera(self.context):
        #     res, fps = FliSdk_V2.FliSerialCamera.GetFps(self.context)
        # print(f"Current camera FPS: {fps}")

        self.wrappedFunc = CWRAPPER(self.newim_callbackfunc)
        FliSdk_V2.AddCallBackNewImage(self.context, self.wrappedFunc, 0, False, 0)
        
        print("Setting camera settings:")
        self.send_command("set sensitivity " + self.settings["sensitivity"])
        # self.send_command("set bias " + self.settings["bias mode"])
        # self.send_command("set flat " + self.settings["flat mode"])
        # self.send_command("set badpixel " + self.settings["badpixel mode"])
        self.send_command("set rawimages on")
        # self.send_command("set imagetags off")
        self.set_exposure(self.settings["exposure_ms"])
        
        print(" ")
        print(self.send_command("fps"))
        print(self.send_command("tint"))
        
        self.loggedims_times_arr = np.zeros(self.n_lines)
        
        if not FliSdk_V2.Update(self.context):
            raise RuntimeError("Error while updating SDK.")
        
        
    def send_command(self, commandstr, return_response=True, verbose=False):
        errorval, response = FliSdk_V2.FliSerialCamera.SendCommand(
            self.context, commandstr
        )
        if verbose:
            print(commandstr)
            print(response)
        if return_response:
            return response
        
    def close(self):
        FliSdk_V2.Stop(self.context)
        FliSdk_V2.Exit(self.context)
        print("Closed context for camera.")
    
    def __exit__(self, *args, **kwargs):
        self.close()
     
    def set_exposure(self,exposure_ms:float):
            self.send_command("set tint " + str(self.settings["exposure_ms"]/1000))
            self.send_command("set fps " + str(int( min(1_000/(self.settings["exposure_ms"]),600) )))
            self.settings["exposure_ms"] = self.send_command("tint")*1000

    def get_img(self):
        self.update_latestim = True
        while self.update_latestim:
            # self.goodtimer(0.1)
            pass
            # time.sleep(0.001)
        return self.latest_im

    def newim_callbackfunc(self, image, ctx):
        
        # new_im = FliSdk_V2.GetRawImageAsNumpyArray(self.context, -1)  # -1 gets most recent image
        
        ArrayType = ctypes.c_uint16 * self.camdims[0] * self.camdims[1]
        pa = ctypes.cast(image, ctypes.POINTER(ArrayType))
        buffer = np.ndarray(
            (self.camdims[1], self.camdims[0]), dtype=np.int16, buffer=pa.contents
        )

        new_im = np.fliplr(np.copy(buffer))
        
        if self.update_latestim:
            self.latest_im = new_im  ### TODO - double check this can't change im in loggedims_list (another copy?)
            self.update_latestim = False
        
        if self.nims_lefttolog > 0:
            self.put(new_im)
            if callable(getattr(self,"get_temp",None)):
                self.cam_temperatures.put( self.get_temp() )

            self.loggedims_times_arr[self.n_lines - self.nims_lefttolog] = time.perf_counter()

            self.nims_lefttolog -= 1

        return None
    
    def collect(self):
        """Collect the hyperspectral datacube."""
        self.start_cam()
        
        self.nims_lefttolog = self.n_lines
        
        with tqdm(total=self.n_lines) as pbar:
            while self.nims_lefttolog > 0:
                time.sleep(0.001)
                pbar.n=self.n_lines-self.nims_lefttolog 
                pbar.refresh()
    
        self.stop_cam()
    
    def start_cam(self):
        FliSdk_V2.Start(self.context)

    def stop_cam(self):
        FliSdk_V2.Stop(self.context)
        
@delegates()
class FirstLightCamera(FirstLightCameraBase, OpenHSI):
    pass
